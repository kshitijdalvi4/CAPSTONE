[
  {
    "question": "What is the time complexity of accessing an element in an array by index?",
    "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
    "correct_answer": 0,
    "explanation": "Array elements can be accessed directly using their index in constant time because arrays store elements in contiguous memory locations.",
    "topic": "Arrays",
    "difficulty": "Easy",
    "keywords": ["array", "time complexity", "access", "index", "O(1)"]
  },
  {
    "question": "Which operation has the worst-case time complexity of O(n) in a dynamic array?",
    "options": ["Access", "Search", "Insertion at end", "Deletion at beginning"],
    "correct_answer": 3,
    "explanation": "Deletion at the beginning requires shifting all remaining elements one position to the left, resulting in O(n) time complexity.",
    "topic": "Arrays",
    "difficulty": "Medium",
    "keywords": ["dynamic array", "deletion", "time complexity", "O(n)", "shifting"]
  },
  {
    "question": "What is the space complexity of merge sort?",
    "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
    "correct_answer": 2,
    "explanation": "Merge sort requires O(n) additional space for the temporary arrays used during the merging process.",
    "topic": "Sorting",
    "difficulty": "Medium",
    "keywords": ["merge sort", "space complexity", "O(n)", "auxiliary space"]
  },
  {
    "question": "Which data structure uses the LIFO (Last In, First Out) principle?",
    "options": ["Queue", "Stack", "Array", "Linked List"],
    "correct_answer": 1,
    "explanation": "Stack follows the LIFO principle where the last element added is the first one to be removed.",
    "topic": "Data Structures",
    "difficulty": "Easy",
    "keywords": ["stack", "LIFO", "last in first out", "data structure"]
  },
  {
    "question": "What is the average time complexity for search operations in a hash table?",
    "options": ["O(1)", "O(log n)", "O(n)", "O(n²)"],
    "correct_answer": 0,
    "explanation": "Hash tables provide O(1) average time complexity for search operations due to direct key-to-index mapping via hash functions.",
    "topic": "Hash Tables",
    "difficulty": "Medium",
    "keywords": ["hash table", "search", "time complexity", "O(1)", "hash function"]
  },
  {
    "question": "Which sorting algorithm has the best worst-case time complexity?",
    "options": ["Quick Sort", "Bubble Sort", "Merge Sort", "Selection Sort"],
    "correct_answer": 2,
    "explanation": "Merge Sort has O(n log n) worst-case time complexity, which is optimal for comparison-based sorting algorithms.",
    "topic": "Sorting",
    "difficulty": "Medium",
    "keywords": ["sorting", "worst case", "time complexity", "merge sort", "O(n log n)"]
  },
  {
    "question": "What is the time complexity of binary search?",
    "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
    "correct_answer": 1,
    "explanation": "Binary search repeatedly divides the search space in half, resulting in O(log n) time complexity.",
    "topic": "Searching",
    "difficulty": "Easy",
    "keywords": ["binary search", "time complexity", "O(log n)", "divide and conquer"]
  },
  {
    "question": "Which data structure is best for implementing a priority queue?",
    "options": ["Array", "Linked List", "Stack", "Heap"],
    "correct_answer": 3,
    "explanation": "Heap is the most efficient data structure for priority queues, providing O(log n) insertion and O(log n) deletion of the highest priority element.",
    "topic": "Data Structures",
    "difficulty": "Medium",
    "keywords": ["priority queue", "heap", "data structure", "efficient"]
  },
  {
    "question": "What is amortized time complexity?",
    "options": ["Worst-case time", "Best-case time", "Average time over sequence of operations", "Space complexity"],
    "correct_answer": 2,
    "explanation": "Amortized time complexity is the average time per operation over a sequence of operations, accounting for expensive operations being rare.",
    "topic": "Complexity Analysis",
    "difficulty": "Hard",
    "keywords": ["amortized", "time complexity", "average", "sequence of operations"]
  },
  {
    "question": "Which traversal method visits nodes in a binary search tree in sorted order?",
    "options": ["Pre-order", "In-order", "Post-order", "Level-order"],
    "correct_answer": 1,
    "explanation": "In-order traversal (left, root, right) visits nodes in a binary search tree in ascending sorted order.",
    "topic": "Trees",
    "difficulty": "Medium",
    "keywords": ["binary search tree", "traversal", "in-order", "sorted order"]
  }
]